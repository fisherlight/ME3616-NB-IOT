###############################################################################
#
# IAR ANSI C/C++ Compiler V8.30.2.160/W32 for ARM         27/Sep/2018  00:43:53
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rtc_ex.c
#    Command line =  
#        -f C:\Users\Simon\AppData\Local\Temp\EW51EA.tmp
#        (C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rtc_ex.c
#        -D USE_HAL_DRIVER -D STM32L031xx -lcN
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM\STM32L031_EM3616_NB\List
#        -o
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM\STM32L031_EM3616_NB\Obj
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM/../Inc\
#        -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM/../Drivers/STM32L0xx_HAL_Driver/Inc\
#        -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM/../Drivers/STM32L0xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM/../Drivers/CMSIS/Device/ST/STM32L0xx/Include\
#        -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM/../Drivers/CMSIS/Include\
#        -I
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM\..\Drivers\ME3616\INC\
#        -Ohz -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.1\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.1\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM\STM32L031_EM3616_NB\List\stm32l0xx_hal_rtc_ex.lst
#    Object file  =  
#        C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\EWARM\STM32L031_EM3616_NB\Obj\stm32l0xx_hal_rtc_ex.o
#
###############################################################################

C:\Users\Simon\Desktop\STM32L031_EM3616_NB\STM32L031_EM3616_NB\Drivers\STM32L0xx_HAL_Driver\Src\stm32l0xx_hal_rtc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32l0xx_hal_rtc_ex.c
      4            * @author  MCD Application Team
      5            * @brief   Extended RTC HAL module driver.
      6            *
      7            *          This file provides firmware functions to manage the following 
      8            *          functionalities of the Real Time Clock (RTC) Extended peripheral:
      9            *           + RTC Time Stamp functions
     10            *           + RTC Tamper functions 
     11            *           + RTC Wake-up functions
     12            *           + Extended Control functions
     13            *           + Extended RTC features functions    
     14            *
     15            @verbatim
     16            ==============================================================================
     17                            ##### How to use this driver #####
     18            ==============================================================================
     19            [..]
     20              (+) Enable the RTC domain access.
     21              (+) Configure the RTC Prescaler (Asynchronous and Synchronous) and RTC hour
     22                  format using the HAL_RTC_Init() function.
     23          
     24            *** RTC Wakeup configuration ***
     25            ================================
     26            [..] 
     27              (+) To configure the RTC Wakeup Clock source and Counter use the HAL_RTCEx_SetWakeUpTimer()
     28                  function. You can also configure the RTC Wakeup timer with interrupt mode 
     29                  using the HAL_RTCEx_SetWakeUpTimer_IT() function.
     30              (+) To read the RTC WakeUp Counter register, use the HAL_RTCEx_GetWakeUpTimer()
     31                  function.
     32                  
     33            *** Outputs configuration ***
     34            =============================
     35            [..] The RTC has 2 different outputs:
     36              (+) RTC_ALARM: this output is used to manage the RTC Alarm A, Alarm B
     37                  and WaKeUp signals.
     38                  To output the selected RTC signal, use the HAL_RTC_Init() function.             
     39              (+) RTC_CALIB: this output is 512Hz signal or 1Hz.
     40                  To enable the RTC_CALIB, use the HAL_RTCEx_SetCalibrationOutPut() function.
     41              (+) Two pins can be used as RTC_ALARM or RTC_CALIB (PC13, PB14) for STM32L05x/6x/7x/8x 
     42          	    and (PA2, PB14) for STM32L03x/4x managed on the RTC_OR register.
     43              (+) When the RTC_CALIB or RTC_ALARM output is selected, the RTC_OUT pin is
     44                  automatically configured in output alternate function. 
     45                  
     46            *** Smooth digital Calibration configuration ***
     47            ================================================
     48            [..]
     49              (+) Configure the RTC Original Digital Calibration Value and the corresponding
     50                  calibration cycle period (32s,16s and 8s) using the HAL_RTCEx_SetSmoothCalib() 
     51                  function.
     52          
     53            *** TimeStamp configuration ***
     54            ===============================
     55            [..]
     56                  (+) Configure the RTC_AF trigger and enable the RTC TimeStamp using the 
     57                      HAL_RTCEx_SetTimeStamp() function. You can also configure the RTC TimeStamp with 
     58                      interrupt mode using the HAL_RTCEx_SetTimeStamp_IT() function.
     59                  (+) To read the RTC TimeStamp Time and Date register, use the HAL_RTCEx_GetTimeStamp()
     60                      function.
     61          
     62            *** Tamper configuration ***
     63            ============================
     64            [..]
     65                  (+) Enable the RTC Tamper and configure the Tamper filter count, trigger Edge 
     66                  or Level according to the Tamper filter (if equal to 0 Edge else Level) 
     67                  value, sampling frequency, NoErase, MaskFlag,  precharge or discharge and
     68                  Pull-UP using the HAL_RTCEx_SetTamper() function. You can configure RTC Tamper
     69                  with interrupt mode using HAL_RTCEx_SetTamper_IT() function.
     70              (+) The default configuration of the Tamper erases the backup registers. To avoid
     71                  erase, enable the NoErase field on the RTC_TAMPCR register.
     72          
     73            *** Backup Data Registers configuration ***
     74            ===========================================
     75            [..]
     76              (+) To write to the RTC Backup Data registers, use the HAL_RTCEx_BKUPWrite()
     77                  function.
     78              (+) To read the RTC Backup Data registers, use the HAL_RTCEx_BKUPRead()
     79                  function.
     80          
     81             @endverbatim
     82            ******************************************************************************
     83            * @attention
     84            *
     85            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     86            *
     87            * Redistribution and use in source and binary forms, with or without modification,
     88            * are permitted provided that the following conditions are met:
     89            *   1. Redistributions of source code must retain the above copyright notice,
     90            *      this list of conditions and the following disclaimer.
     91            *   2. Redistributions in binary form must reproduce the above copyright notice,
     92            *      this list of conditions and the following disclaimer in the documentation
     93            *      and/or other materials provided with the distribution.
     94            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     95            *      may be used to endorse or promote products derived from this software
     96            *      without specific prior written permission.
     97            *
     98            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     99            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    100            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    101            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    102            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    103            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    104            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    105            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    106            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    107            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    108            *
    109            ******************************************************************************  
    110            */
    111          
    112          /* Includes ------------------------------------------------------------------*/
    113          #include "stm32l0xx_hal.h"
    114          
    115          /** @addtogroup STM32L0xx_HAL_Driver
    116            * @{
    117            */
    118          
    119          /** @addtogroup RTCEx
    120            * @brief RTC Extended HAL module driver
    121            * @{
    122            */
    123          
    124          #ifdef HAL_RTC_MODULE_ENABLED
    125          
    126          /* Private typedef -----------------------------------------------------------*/
    127          /* Private define ------------------------------------------------------------*/
    128          /* Private macro -------------------------------------------------------------*/
    129          /* Private variables ---------------------------------------------------------*/
    130          /* Private function prototypes -----------------------------------------------*/
    131          /* Exported functions --------------------------------------------------------*/
    132          
    133          /** @addtogroup RTCEx_Exported_Functions
    134            * @{
    135            */
    136          
    137          
    138          /** @addtogroup RTCEx_Exported_Functions_Group1
    139           *  @brief   RTC TimeStamp and Tamper functions
    140            *
    141          @verbatim
    142           ===============================================================================
    143                           ##### RTC TimeStamp and Tamper functions #####
    144           ===============================================================================
    145           
    146           [..] This section provides functions allowing to configure TimeStamp feature
    147          
    148          @endverbatim
    149            * @{
    150            */
    151          
    152          /**
    153            * @brief  Set TimeStamp.
    154            * @note   This API must be called before enabling the TimeStamp feature.
    155            * @param  hrtc: RTC handle
    156            * @param  TimeStampEdge: Specifies the pin edge on which the TimeStamp is
    157            *         activated.
    158            *          This parameter can be one of the following values:
    159            *             @arg RTC_TIMESTAMPEDGE_RISING: the Time stamp event occurs on the  
    160            *                                        rising edge of the related pin.
    161            *             @arg RTC_TIMESTAMPEDGE_FALLING: the Time stamp event occurs on the 
    162            *                                         falling edge of the related pin.
    163            * @param  RTC_TimeStampPin: specifies the RTC TimeStamp Pin.
    164            *          This parameter can be one of the following values:
    165            *             @arg RTC_TIMESTAMPPIN_DEFAULT: PC13 is selected as RTC TimeStamp Pin on STM32L05x/6x/7x/8x 
    166            *                                            and PA2 on STM32L03x/4x/2x/1x.
    167            * @retval HAL status
    168            */
    169          HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
    170          {
    171            uint32_t tmpreg = 0U;
    172          
    173            /* Check the parameters */
    174            assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
    175            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
    176          
    177            /* Process Locked */
    178            __HAL_LOCK(hrtc);
    179          
    180            hrtc->State = HAL_RTC_STATE_BUSY;
    181          
    182            /* Get the RTC_CR register and clear the bits to be configured */
    183            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
    184          
    185            tmpreg|= TimeStampEdge;
    186          
    187            /* Disable the write protection for RTC registers */
    188            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
    189          
    190            /* Configure the Time Stamp TSEDGE and Enable bits */
    191            hrtc->Instance->CR = (uint32_t)tmpreg;
    192          
    193            __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
    194          
    195            /* Enable the write protection for RTC registers */
    196            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    197          
    198            /* Change RTC state */
    199            hrtc->State = HAL_RTC_STATE_READY; 
    200          
    201            /* Process Unlocked */ 
    202            __HAL_UNLOCK(hrtc);
    203          
    204            return HAL_OK;
    205          }
    206          
    207          /**
    208            * @brief  Set TimeStamp with Interrupt.
    209            * @param  hrtc: RTC handle
    210            * @note   This API must be called before enabling the TimeStamp feature.
    211            * @param  TimeStampEdge: Specifies the pin edge on which the TimeStamp is
    212            *         activated.
    213            *          This parameter can be one of the following values:
    214            *             @arg RTC_TIMESTAMPEDGE_RISING: the Time stamp event occurs on the  
    215            *                                        rising edge of the related pin.
    216            *             @arg RTC_TIMESTAMPEDGE_FALLING: the Time stamp event occurs on the 
    217            *                                         falling edge of the related pin.
    218            * @param  RTC_TimeStampPin: Specifies the RTC TimeStamp Pin.
    219            *          This parameter can be one of the following values:
    220            *             @arg RTC_TIMESTAMPPIN_DEFAULT: PC13 is selected as RTC TimeStamp Pin on STM32L05x/6x/7x/8x 
    221            *                                            and PA2 on STM32L03x/4x/2x/1x.
    222            * @retval HAL status
    223            */
    224          HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp_IT(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
    225          {
    226            uint32_t tmpreg = 0U;
    227          
    228            /* Check the parameters */
    229            assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
    230            assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
    231          
    232            /* Process Locked */ 
    233            __HAL_LOCK(hrtc);
    234          
    235            hrtc->State = HAL_RTC_STATE_BUSY;
    236          
    237            /* Get the RTC_CR register and clear the bits to be configured */
    238            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
    239          
    240            tmpreg |= TimeStampEdge;
    241          
    242            /* Disable the write protection for RTC registers */
    243            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
    244          
    245            /* Configure the Time Stamp TSEDGE and Enable bits */
    246            hrtc->Instance->CR = (uint32_t)tmpreg;
    247          
    248            __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
    249          
    250            /* Enable IT timestamp */
    251            __HAL_RTC_TIMESTAMP_ENABLE_IT(hrtc,RTC_IT_TS);
    252          
    253            /* RTC timestamp Interrupt Configuration: EXTI configuration */
    254            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
    255          
    256            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
    257          
    258            /* Enable the write protection for RTC registers */
    259            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    260          
    261            hrtc->State = HAL_RTC_STATE_READY;
    262          
    263            /* Process Unlocked */
    264            __HAL_UNLOCK(hrtc);
    265          
    266            return HAL_OK;
    267          }
    268          
    269          /**
    270            * @brief  Deactivate TimeStamp.
    271            * @param  hrtc: RTC handle
    272            * @retval HAL status
    273            */
    274          HAL_StatusTypeDef HAL_RTCEx_DeactivateTimeStamp(RTC_HandleTypeDef *hrtc)
    275          {
    276            uint32_t tmpreg = 0U;
    277          
    278            /* Process Locked */
    279            __HAL_LOCK(hrtc);
    280          
    281            hrtc->State = HAL_RTC_STATE_BUSY;
    282          
    283            /* Disable the write protection for RTC registers */
    284            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
    285          
    286            /* In case of interrupt mode is used, the interrupt source must disabled */
    287            __HAL_RTC_TIMESTAMP_DISABLE_IT(hrtc, RTC_IT_TS);
    288          
    289            /* Get the RTC_CR register and clear the bits to be configured */
    290            tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
    291          
    292            /* Configure the Time Stamp TSEDGE and Enable bits */
    293            hrtc->Instance->CR = (uint32_t)tmpreg;
    294          
    295            /* Enable the write protection for RTC registers */
    296            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
    297          
    298            hrtc->State = HAL_RTC_STATE_READY;
    299          
    300            /* Process Unlocked */
    301            __HAL_UNLOCK(hrtc);
    302          
    303            return HAL_OK;
    304          }
    305          
    306          /**
    307            * @brief  Get the RTC TimeStamp value.
    308            * @param  hrtc: RTC handle
    309          
    310            * @param  sTimeStamp: Pointer to Time structure
    311            * @param  sTimeStampDate: Pointer to Date structure  
    312            * @param  Format: specifies the format of the entered parameters.
    313            *          This parameter can be one of the following values:
    314            *             @arg RTC_FORMAT_BIN: Binary data format 
    315            *             @arg RTC_FORMAT_BCD: BCD data format
    316            * @retval HAL status
    317            */
    318          HAL_StatusTypeDef HAL_RTCEx_GetTimeStamp(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef* sTimeStamp, RTC_DateTypeDef* sTimeStampDate, uint32_t Format)
    319          {
    320            uint32_t tmptime = 0U, tmpdate = 0U;
    321          
    322            /* Check the parameters */
    323            assert_param(IS_RTC_FORMAT(Format));
    324          
    325            /* Get the TimeStamp time and date registers values */
    326            tmptime = (uint32_t)(hrtc->Instance->TSTR & RTC_TR_RESERVED_MASK);
    327            tmpdate = (uint32_t)(hrtc->Instance->TSDR & RTC_DR_RESERVED_MASK);
    328          
    329            /* Fill the Time structure fields with the read parameters */
    330            sTimeStamp->Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16U);
    331            sTimeStamp->Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8U);
    332            sTimeStamp->Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
    333            sTimeStamp->TimeFormat = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16U);
    334            sTimeStamp->SubSeconds = (uint32_t) hrtc->Instance->TSSSR;
    335          
    336            /* Fill the Date structure fields with the read parameters */
    337            sTimeStampDate->Year = 0U;
    338            sTimeStampDate->Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8U);
    339            sTimeStampDate->Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
    340            sTimeStampDate->WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13U);
    341          
    342            /* Check the input parameters format */
    343            if(Format == RTC_FORMAT_BIN)
    344            {
    345              /* Convert the TimeStamp structure parameters to Binary format */
    346              sTimeStamp->Hours = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Hours);
    347              sTimeStamp->Minutes = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Minutes);
    348              sTimeStamp->Seconds = (uint8_t)RTC_Bcd2ToByte(sTimeStamp->Seconds);
    349          
    350              /* Convert the DateTimeStamp structure parameters to Binary format */
    351              sTimeStampDate->Month = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Month);
    352              sTimeStampDate->Date = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->Date);
    353              sTimeStampDate->WeekDay = (uint8_t)RTC_Bcd2ToByte(sTimeStampDate->WeekDay);
    354            }
    355          
    356            /* Clear the TIMESTAMP Flag */
    357            __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
    358          
    359            return HAL_OK;
    360          }
    361          
    362          /**
    363            * @brief  Set Tamper
    364            * @note   By calling this API we disable the tamper interrupt for all tampers.
    365            * @param  hrtc: RTC handle
    366            * @param  sTamper: Pointer to Tamper Structure.
    367            * @retval HAL status
    368            */
    369          HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
    370          {
    371            uint32_t tmpreg = 0U;
    372          
    373            /* Check the parameters */
    374            assert_param( IS_RTC_TAMPER(sTamper->Tamper));
    375            assert_param( IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    376            assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
    377            assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
    378            assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
    379            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
    380            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
    381            assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
    382            assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
    383          
    384            /* Process Locked */
    385            __HAL_LOCK(hrtc);
    386          
    387            hrtc->State = HAL_RTC_STATE_BUSY;
    388          
    389            /* Configure the tamper trigger */
    390            if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
    391            { 
    392              sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U); 
    393            }
    394          
    395            if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
    396            { 
    397              sTamper->NoErase = 0U;
    398          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    399              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    400              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    401              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    402              defined (STM32L031xx) || defined (STM32L041xx)
    403          
    404              if((sTamper->Tamper & RTC_TAMPER_1) != 0U)
    405              {
    406                sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
    407              }
    408          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    409                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    410                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    411                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    412                  * (STM32L031xx) || (STM32L041xx)
    413                  */
    414          
    415              if((sTamper->Tamper & RTC_TAMPER_2) != 0U)
    416              {
    417                sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
    418              }
    419          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    420              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    421              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    422          
    423              if((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    424              {
    425                sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
    426              }
    427          
    428          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    429                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
    430                  */
    431            }
    432          
    433            if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
    434            {
    435              sTamper->MaskFlag = 0U;
    436              
    437          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    438              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    439              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    440              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    441              defined (STM32L031xx) || defined (STM32L041xx)
    442          
    443              if((sTamper->Tamper & RTC_TAMPER_1) != 0U)
    444              {
    445                sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
    446              }
    447          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    448                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    449                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    450                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    451                  * (STM32L031xx) || (STM32L041xx)
    452                  */
    453            
    454              if((sTamper->Tamper & RTC_TAMPER_2) != 0U)
    455              {
    456                sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
    457              }
    458          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    459              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    460              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    461          
    462              if((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    463              {
    464                sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
    465              }
    466          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) || 
    467                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx)|| (STM32L011xx) || (STM32L021xx)
    468                  */
    469            }
    470          
    471            /* Configure the RTC_TAMPCR register */
    472            tmpreg = (uint32_t)((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
    473                      (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency |\
    474                      (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | (uint32_t)sTamper->TimeStampOnTamperDetection);
    475          
    476          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    477              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx)
    478            hrtc->Instance->TAMPCR &= ((uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    479                                                   RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH        |\
    480                                                   RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE         |\
    481                                                   RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP1NOERASE | RTC_TAMPCR_TAMP2NOERASE|\
    482                                                   RTC_TAMPCR_TAMP1MF | RTC_TAMPCR_TAMP2MF));
    483          
    484          #elif defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    485                defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    486                defined (STM32L031xx) || defined (STM32L041xx)      
    487            hrtc->Instance->TAMPCR &= ((uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    488                                                  RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH         |\
    489                                                  RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE          |\
    490                                                  RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP3IE | RTC_TAMPCR_TAMP1NOERASE      |\
    491                                                  RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP3NOERASE | RTC_TAMPCR_TAMP1MF |\
    492                                                  RTC_TAMPCR_TAMP2MF | RTC_TAMPCR_TAMP3MF));
    493                                                  
    494          #elif defined (STM32L011xx) || defined (STM32L021xx)
    495            hrtc->Instance->TAMPCR &= ((uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    496                                                  RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH         |\
    497                                                  RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE                               |\
    498                                                  RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP3IE                                |\
    499                                                  RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP3NOERASE                      |\
    500                                                  RTC_TAMPCR_TAMP2MF | RTC_TAMPCR_TAMP3MF));
    501                                                  
    502          #endif /* (STM32L011xx) || (STM32L021xx) 
    503                  */
    504           
    505            hrtc->Instance->TAMPCR |= tmpreg;
    506          
    507            hrtc->State = HAL_RTC_STATE_READY;
    508          
    509            /* Process Unlocked */
    510            __HAL_UNLOCK(hrtc);
    511          
    512            return HAL_OK;
    513          }
    514          
    515          /**
    516            * @brief  Set Tamper with interrupt.
    517            * @note   By calling this API we force the tamper interrupt for all tampers.
    518            * @param  hrtc: RTC handle
    519            * @param  sTamper: Pointer to RTC Tamper.
    520            * @retval HAL status
    521            */
    522          HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
    523          {
    524            uint32_t tmpreg = 0U;
    525          
    526            /* Check the parameters */
    527            assert_param( IS_RTC_TAMPER(sTamper->Tamper));
    528            assert_param(IS_RTC_TAMPER_INTERRUPT(sTamper->Interrupt));
    529            assert_param( IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
    530            assert_param(IS_RTC_TAMPER_ERASE_MODE(sTamper->NoErase));
    531            assert_param(IS_RTC_TAMPER_MASKFLAG_STATE(sTamper->MaskFlag));
    532            assert_param(IS_RTC_TAMPER_FILTER(sTamper->Filter));
    533            assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(sTamper->SamplingFrequency));
    534            assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(sTamper->PrechargeDuration));
    535            assert_param(IS_RTC_TAMPER_PULLUP_STATE(sTamper->TamperPullUp));
    536            assert_param(IS_RTC_TAMPER_TIMESTAMPONTAMPER_DETECTION(sTamper->TimeStampOnTamperDetection));
    537          
    538            /* Process Locked */
    539            __HAL_LOCK(hrtc);
    540          
    541            hrtc->State = HAL_RTC_STATE_BUSY;
    542          
    543            /* Configure the tamper trigger */
    544            if(sTamper->Trigger != RTC_TAMPERTRIGGER_RISINGEDGE)
    545            {
    546              sTamper->Trigger = (uint32_t)(sTamper->Tamper << 1U);
    547            }
    548          
    549            if(sTamper->NoErase != RTC_TAMPER_ERASE_BACKUP_ENABLE)
    550            { 
    551              sTamper->NoErase = 0U;
    552              
    553          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    554              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    555              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    556              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    557              defined (STM32L031xx) || defined (STM32L041xx)
    558          
    559              if((sTamper->Tamper & RTC_TAMPER_1) != 0U)
    560              {
    561                sTamper->NoErase |= RTC_TAMPCR_TAMP1NOERASE;
    562              }
    563          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    564                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    565                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    566                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    567                  * (STM32L031xx) || (STM32L041xx)
    568                  */
    569          
    570                  
    571              if((sTamper->Tamper & RTC_TAMPER_2) != 0U)
    572              {
    573                sTamper->NoErase |= RTC_TAMPCR_TAMP2NOERASE;
    574              }
    575          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    576              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    577              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    578          
    579              if((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    580              {
    581                sTamper->NoErase |= RTC_TAMPCR_TAMP3NOERASE;
    582              }
    583          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    584                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
    585                  */
    586            }
    587          
    588            if(sTamper->MaskFlag != RTC_TAMPERMASK_FLAG_DISABLE)
    589            {
    590              sTamper->MaskFlag = 0U;
    591              
    592          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    593              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    594              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    595              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    596              defined (STM32L031xx) || defined (STM32L041xx)
    597              if((sTamper->Tamper & RTC_TAMPER_1) != 0U)
    598              {
    599                sTamper->MaskFlag |= RTC_TAMPCR_TAMP1MF;
    600              }
    601          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    602                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    603                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    604                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    605                  * (STM32L031xx) || (STM32L041xx)
    606                  */
    607          
    608              if((sTamper->Tamper & RTC_TAMPER_2) != 0U)
    609              {
    610                sTamper->MaskFlag |= RTC_TAMPCR_TAMP2MF;
    611              }
    612          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    613              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    614              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    615          
    616              if((sTamper->Tamper & RTC_TAMPER_3) != 0U)
    617              {
    618                sTamper->MaskFlag |= RTC_TAMPCR_TAMP3MF;
    619              }
    620          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    621                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
    622                  */
    623            }
    624          
    625            /* Configure the RTC_TAMPCR register */    
    626            tmpreg = (uint32_t)((uint32_t)sTamper->Tamper | (uint32_t)sTamper->Interrupt | (uint32_t)sTamper->Trigger  | (uint32_t)sTamper->NoErase |\
    627                      (uint32_t)sTamper->MaskFlag | (uint32_t)sTamper->Filter | (uint32_t)sTamper->SamplingFrequency                                |\
    628                      (uint32_t)sTamper->PrechargeDuration | (uint32_t)sTamper->TamperPullUp | (uint32_t)sTamper->TimeStampOnTamperDetection);
    629            
    630          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    631              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx)
    632            hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    633                                                 RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH         |\
    634                                                 RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE          |\
    635                                                 RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP1NOERASE | RTC_TAMPCR_TAMP2NOERASE |\
    636                                                 RTC_TAMPCR_TAMP1MF | RTC_TAMPCR_TAMP2MF);
    637          
    638          #elif defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    639                defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    640                defined (STM32L031xx) || defined (STM32L041xx)    
    641            hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    642                                                 RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH    |\
    643                                                 RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE | RTC_TAMPCR_TAMP1IE     |\
    644                                                 RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP3IE | RTC_TAMPCR_TAMP1NOERASE |\
    645                                                 RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP3NOERASE | RTC_TAMPCR_TAMP1MF |\
    646                                                 RTC_TAMPCR_TAMP2MF | RTC_TAMPCR_TAMP3MF);
    647          
    648          #elif defined (STM32L011xx) || defined (STM32L021xx)
    649            hrtc->Instance->TAMPCR &= (uint32_t)~((uint32_t)sTamper->Tamper | (uint32_t)(sTamper->Tamper << 1U) | RTC_TAMPCR_TAMPTS |\
    650                                                 RTC_TAMPCR_TAMPFREQ | RTC_TAMPCR_TAMPFLT | RTC_TAMPCR_TAMPPRCH    |\
    651                                                 RTC_TAMPCR_TAMPPUDIS | RTC_TAMPCR_TAMPIE                          |\
    652                                                 RTC_TAMPCR_TAMP2IE | RTC_TAMPCR_TAMP3IE                           |\
    653                                                 RTC_TAMPCR_TAMP2NOERASE | RTC_TAMPCR_TAMP3NOERASE                 |\
    654                                                 RTC_TAMPCR_TAMP2MF | RTC_TAMPCR_TAMP3MF);
    655          
    656          #endif /* (STM32L011xx) || (STM32L021xx) 
    657                  */
    658          
    659            hrtc->Instance->TAMPCR |= tmpreg;
    660          
    661            /* RTC Tamper Interrupt Configuration: EXTI configuration */
    662            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_IT();
    663          
    664            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_ENABLE_RISING_EDGE();
    665          
    666            hrtc->State = HAL_RTC_STATE_READY;
    667          
    668            /* Process Unlocked */
    669            __HAL_UNLOCK(hrtc);
    670          
    671            return HAL_OK;
    672          }
    673          
    674          /**
    675            * @brief  Deactivate Tamper.
    676            * @param  hrtc: RTC handle
    677            * @param  Tamper: Selected tamper pin.
    678            *          This parameter can be RTC_Tamper_1 and/or RTC_TAMPER_2 for STM32L05x/6x.
    679            *          This parameter can be any combination of RTC_TAMPER_1, RTC_TAMPER_2 and RTC_TAMPER_3 for STM32L01x/2x/3x/7x/8x.        
    680            * @retval HAL status
    681            */
    682          HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
    683          {
    684            assert_param( IS_RTC_TAMPER(Tamper));
    685          
    686            /* Process Locked */
    687            __HAL_LOCK(hrtc);
    688          
    689            hrtc->State = HAL_RTC_STATE_BUSY;
    690          
    691            /* Disable the selected Tamper pin */
    692            hrtc->Instance->TAMPCR &= ((uint32_t)~Tamper);
    693            
    694          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    695              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    696              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    697              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    698              defined (STM32L031xx) || defined (STM32L041xx)
    699            if ((Tamper & RTC_TAMPER_1) != 0U)
    700            {
    701              /* Disable the Tamper1 interrupt */
    702              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP1));
    703            }
    704            
    705          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    706                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    707                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    708                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    709                  * (STM32L031xx) || (STM32L041xx)
    710                  */
    711            
    712            if ((Tamper & RTC_TAMPER_2) != 0U)
    713            {
    714              /* Disable the Tamper2 interrupt */
    715              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP2));
    716            }
    717          
    718          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    719              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    720              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    721              
    722              if ((Tamper & RTC_TAMPER_3) != 0U)
    723            {
    724              /* Disable the Tamper3 interrupt */
    725              hrtc->Instance->TAMPCR &= ((uint32_t)~(RTC_IT_TAMP | RTC_IT_TAMP3));
    726            }
    727            
    728          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    729              * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
    730              */
    731              
    732            hrtc->State = HAL_RTC_STATE_READY;
    733          
    734            /* Process Unlocked */
    735            __HAL_UNLOCK(hrtc);
    736          
    737            return HAL_OK;
    738          }
    739          
    740          /**
    741            * @brief  Handle TimeStamp interrupt request.
    742            * @param  hrtc: RTC handle
    743            * @retval None
    744            */
    745          void HAL_RTCEx_TamperTimeStampIRQHandler(RTC_HandleTypeDef *hrtc)
    746          { 
    747            /* Get the TimeStamp interrupt source enable status */
    748            if(__HAL_RTC_TIMESTAMP_GET_IT_SOURCE(hrtc, RTC_IT_TS) != RESET)
    749            {
    750              /* Get the pending status of the TIMESTAMP Interrupt */
    751              if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) != RESET)
    752              {
    753                /* TIMESTAMP callback */ 
    754                HAL_RTCEx_TimeStampEventCallback(hrtc);
    755                
    756                /* Clear the TIMESTAMP interrupt pending bit */
    757                __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSF);
    758              }
    759            }
    760          
    761          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    762              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    763              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    764              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    765              defined (STM32L031xx) || defined (STM32L041xx)
    766          
    767            /* Get the Tamper1 interrupts source enable status */
    768            if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP1) != RESET)
    769            {
    770              /* Get the pending status of the Tamper1 Interrupt */
    771              if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != RESET)
    772              {
    773                /* Tamper1 callback */
    774                HAL_RTCEx_Tamper1EventCallback(hrtc);
    775          
    776                /* Clear the Tamper1 interrupt pending bit */
    777                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
    778              }
    779            }
    780          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    781                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    782                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    783                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    784                  * (STM32L031xx) || (STM32L041xx)
    785                  */
    786          
    787            /* Get the Tamper2 interrupts source enable status */
    788            if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP2) != RESET)
    789            {
    790              /* Get the pending status of the Tamper2 Interrupt */
    791              if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) != RESET)
    792              {
    793                /* Tamper2 callback */
    794                HAL_RTCEx_Tamper2EventCallback(hrtc);
    795          
    796                /* Clear the Tamper2 interrupt pending bit */
    797                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP2F);
    798              }
    799            }
    800          
    801          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    802              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    803              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    804              
    805            /* Get the Tamper3 interrupts source enable status */
    806            if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP | RTC_IT_TAMP3) != RESET)
    807            {
    808              /* Get the pending status of the Tamper3 Interrupt */
    809              if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP3F) != RESET)
    810              {
    811                /* Tamper3 callback */
    812                HAL_RTCEx_Tamper3EventCallback(hrtc);
    813          
    814                /* Clear the Tamper3 interrupt pending bit */
    815                __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP3F);
    816              }
    817            }
    818            
    819          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    820                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) ||
    821          	    * (STM32L011xx) || (STM32L021xx)
    822                  */
    823          
    824            /* Clear the EXTI's Flag for RTC TimeStamp and Tamper */
    825            __HAL_RTC_TAMPER_TIMESTAMP_EXTI_CLEAR_FLAG();
    826          
    827            /* Change RTC state */
    828            hrtc->State = HAL_RTC_STATE_READY;
    829          }
    830          
    831          /**
    832            * @brief  TimeStamp callback. 
    833            * @param  hrtc: RTC handle
    834            * @retval None
    835            */
    836          __weak void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
    837          {
    838            /* Prevent unused argument(s) compilation warning */
    839            UNUSED(hrtc);
    840          
    841            /* NOTE : This function should not be modified, when the callback is needed,
    842                      the HAL_RTCEx_TimeStampEventCallback could be implemented in the user file
    843            */
    844          }
    845          
    846          /**
    847            * @brief  Tamper 1 callback.
    848            * @param  hrtc: RTC handle
    849            * @retval None
    850            */
    851          __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
    852          {
    853            /* Prevent unused argument(s) compilation warning */
    854            UNUSED(hrtc);
    855          
    856            /* NOTE : This function should not be modified, when the callback is needed,
    857                      the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
    858             */
    859          }
    860          
    861          /**
    862            * @brief  Tamper 2 callback. 
    863            * @param  hrtc: RTC handle
    864            * @retval None
    865            */
    866          __weak void HAL_RTCEx_Tamper2EventCallback(RTC_HandleTypeDef *hrtc)
    867          {
    868            /* Prevent unused argument(s) compilation warning */
    869            UNUSED(hrtc);
    870          
    871            /* NOTE : This function should not be modified, when the callback is needed,
    872                      the HAL_RTCEx_Tamper2EventCallback could be implemented in the user file
    873             */
    874          }
    875          
    876          
    877          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    878              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    879              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
    880              
    881          /**
    882            * @brief  Tamper 3 callback. 
    883            * @param  hrtc: RTC handle
    884            * @retval None
    885            */
    886          __weak void HAL_RTCEx_Tamper3EventCallback(RTC_HandleTypeDef *hrtc)
    887          {
    888            /* Prevent unused argument(s) compilation warning */
    889            UNUSED(hrtc);
    890          
    891            /* NOTE : This function should not be modified, when the callback is needed,
    892                      the HAL_RTCEx_Tamper3EventCallback could be implemented in the user file
    893             */
    894          }
    895          
    896          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    897              * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
    898              */
    899          
    900          
    901          /**
    902            * @brief  Handle TimeStamp polling request.
    903            * @param  hrtc: RTC handle
    904            * @param  Timeout: Timeout duration
    905            * @retval HAL status
    906            */
    907          HAL_StatusTypeDef HAL_RTCEx_PollForTimeStampEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    908          { 
    909            uint32_t tickstart = HAL_GetTick();
    910          
    911            while(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSF) == RESET)
    912            {
    913              if(__HAL_RTC_TIMESTAMP_GET_FLAG(hrtc, RTC_FLAG_TSOVF) != RESET)
    914              {
    915                /* Clear the TIMESTAMP OverRun Flag */
    916                __HAL_RTC_TIMESTAMP_CLEAR_FLAG(hrtc, RTC_FLAG_TSOVF);
    917          
    918                /* Change TIMESTAMP state */
    919                hrtc->State = HAL_RTC_STATE_ERROR; 
    920          
    921                return HAL_ERROR; 
    922              }
    923          
    924              if(Timeout != HAL_MAX_DELAY)
    925              {
    926                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
    927                {
    928                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
    929                  return HAL_TIMEOUT;
    930                }
    931              }
    932            }
    933          
    934            /* Change RTC state */
    935            hrtc->State = HAL_RTC_STATE_READY;
    936            
    937            return HAL_OK;
    938          }
    939          
    940          #if defined (STM32L063xx) || defined (STM32L062xx) || defined (STM32L061xx) || \
    941              defined (STM32L053xx) || defined (STM32L052xx) || defined (STM32L051xx) ||\
    942              defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
    943              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
    944              defined (STM32L031xx) || defined (STM32L041xx)
    945          /**
    946            * @brief  Handle Tamper 1 Polling.
    947            * @param  hrtc: RTC handle
    948            * @param  Timeout: Timeout duration
    949            * @retval HAL status
    950            */
    951          HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    952          {
    953            uint32_t tickstart = HAL_GetTick();
    954          
    955            /* Get the status of the Interrupt */
    956            while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F)== RESET)
    957            {
    958              if(Timeout != HAL_MAX_DELAY)
    959              {
    960                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
    961                {
    962                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
    963                  return HAL_TIMEOUT;
    964                }
    965              }
    966            }
    967          
    968            /* Clear the Tamper Flag */
    969            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
    970            
    971            /* Change RTC state */
    972            hrtc->State = HAL_RTC_STATE_READY;
    973            
    974            return HAL_OK; 
    975          }
    976          #endif /* (STM32L063xx) || (STM32L062xx) || (STM32L061xx) ||
    977                  * (STM32L053xx) || (STM32L052xx) || (STM32L051xx) ||
    978                  * (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
    979                  * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || 
    980                  * (STM32L031xx) || (STM32L041xx)
    981                  */
    982          
    983          /**
    984            * @brief  Handle Tamper 2 Polling.
    985            * @param  hrtc: RTC handle
    986            * @param  Timeout: Timeout duration
    987            * @retval HAL status
    988            */
    989          HAL_StatusTypeDef HAL_RTCEx_PollForTamper2Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
    990          {
    991            uint32_t tickstart = HAL_GetTick();
    992          
    993            /* Get the status of the Interrupt */
    994            while(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP2F) == RESET)
    995            {
    996              if(Timeout != HAL_MAX_DELAY)
    997              {
    998                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
    999                {
   1000                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1001                  return HAL_TIMEOUT;
   1002                }
   1003              }
   1004            }
   1005          
   1006            /* Clear the Tamper Flag */
   1007            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP2F);
   1008          
   1009            /* Change RTC state */
   1010            hrtc->State = HAL_RTC_STATE_READY;
   1011          
   1012            return HAL_OK;
   1013          }
   1014          
   1015          
   1016          #if defined (STM32L083xx) || defined (STM32L082xx) || defined (STM32L081xx) || \
   1017              defined (STM32L073xx) || defined (STM32L072xx) || defined (STM32L071xx) || \
   1018              defined (STM32L031xx) || defined (STM32L041xx) || defined (STM32L011xx) || defined (STM32L021xx) 
   1019              
   1020          /**
   1021            * @brief  Handle Tamper 3 Polling.
   1022            * @param  hrtc: RTC handle
   1023            * @param  Timeout: Timeout duration
   1024            * @retval HAL status
   1025            */
   1026          HAL_StatusTypeDef HAL_RTCEx_PollForTamper3Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1027          {  
   1028            uint32_t tickstart = HAL_GetTick();
   1029          
   1030            /* Get the status of the Interrupt */
   1031            while(__HAL_RTC_TAMPER_GET_FLAG(hrtc,RTC_FLAG_TAMP3F) == RESET)
   1032            {
   1033              if(Timeout != HAL_MAX_DELAY)
   1034              {
   1035                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
   1036                {
   1037                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1038                  return HAL_TIMEOUT;
   1039                }
   1040              }
   1041            }
   1042          
   1043            /* Clear the Tamper Flag */
   1044            __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP3F);
   1045          
   1046            /* Change RTC state */
   1047            hrtc->State = HAL_RTC_STATE_READY;
   1048          
   1049            return HAL_OK;
   1050          }
   1051          #endif /* (STM32L083xx) || (STM32L082xx) || (STM32L081xx) ||
   1052              * (STM32L073xx) || (STM32L072xx) || (STM32L071xx) || (STM32L031xx) || (STM32L041xx) || (STM32L011xx) || (STM32L021xx)
   1053              */
   1054          
   1055          /**
   1056            * @}
   1057            */
   1058            
   1059          /** @addtogroup RTCEx_Exported_Functions_Group2
   1060            * @brief    RTC Wake-up functions
   1061            *
   1062          @verbatim   
   1063           ===============================================================================
   1064                                  ##### RTC Wake-up functions #####
   1065           ===============================================================================  
   1066           
   1067           [..] This section provides functions allowing to configure Wake-up feature
   1068          
   1069          @endverbatim
   1070            * @{
   1071            */
   1072          
   1073          /**
   1074            * @brief  Set wake up timer.
   1075            * @param  hrtc: RTC handle
   1076            * @param  WakeUpCounter: Wake up counter
   1077            * @param  WakeUpClock: Wake up clock
   1078            * @retval HAL status
   1079            */
   1080          HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
   1081          {
   1082            uint32_t tickstart = 0U;
   1083          
   1084            /* Check the parameters */
   1085            assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
   1086            assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
   1087          
   1088            /* Process Locked */ 
   1089            __HAL_LOCK(hrtc);
   1090          
   1091            hrtc->State = HAL_RTC_STATE_BUSY;
   1092          
   1093            /* Disable the write protection for RTC registers */
   1094            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1095           
   1096            /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
   1097            if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET){
   1098              tickstart = HAL_GetTick();
   1099          
   1100             /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
   1101             while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
   1102             {
   1103              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1104                {
   1105                 /* Enable the write protection for RTC registers */
   1106                 __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1107          
   1108                 hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1109          
   1110                 /* Process Unlocked */ 
   1111                 __HAL_UNLOCK(hrtc);
   1112          
   1113                 return HAL_TIMEOUT;
   1114                }
   1115              }
   1116            }
   1117          
   1118            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   1119          
   1120            tickstart = HAL_GetTick();
   1121          
   1122            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1123            while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
   1124            {
   1125              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1126              {
   1127                /* Enable the write protection for RTC registers */
   1128                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1129          
   1130                hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1131          
   1132                /* Process Unlocked */ 
   1133                __HAL_UNLOCK(hrtc);
   1134          
   1135                return HAL_TIMEOUT;
   1136              }
   1137            }
   1138          
   1139            /* Clear the Wakeup Timer clock source bits in CR register */
   1140            hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   1141          
   1142            /* Configure the clock source */
   1143            hrtc->Instance->CR |= (uint32_t)WakeUpClock;
   1144          
   1145            /* Configure the Wakeup Timer counter */
   1146            hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
   1147          
   1148             /* Enable the Wakeup Timer */
   1149            __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
   1150          
   1151            /* Enable the write protection for RTC registers */
   1152            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1153          
   1154            hrtc->State = HAL_RTC_STATE_READY;
   1155          
   1156            /* Process Unlocked */
   1157            __HAL_UNLOCK(hrtc);
   1158          
   1159            return HAL_OK;
   1160          }
   1161          
   1162          /**
   1163            * @brief  Set wake up timer with interrupt.
   1164            * @param  hrtc: RTC handle
   1165            * @param  WakeUpCounter: Wake up counter
   1166            * @param  WakeUpClock: Wake up clock  
   1167            * @retval HAL status
   1168            */
   1169          HAL_StatusTypeDef HAL_RTCEx_SetWakeUpTimer_IT(RTC_HandleTypeDef *hrtc, uint32_t WakeUpCounter, uint32_t WakeUpClock)
   1170          {
   1171            uint32_t tickstart = 0U;
   1172          
   1173            /* Check the parameters */
   1174            assert_param(IS_RTC_WAKEUP_CLOCK(WakeUpClock));
   1175            assert_param(IS_RTC_WAKEUP_COUNTER(WakeUpCounter));
   1176          
   1177            /* Process Locked */ 
   1178            __HAL_LOCK(hrtc);
   1179          
   1180            hrtc->State = HAL_RTC_STATE_BUSY;
   1181          
   1182            /* Disable the write protection for RTC registers */
   1183            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1184          
   1185            /*Check RTC WUTWF flag is reset only when wake up timer enabled*/
   1186            if((hrtc->Instance->CR & RTC_CR_WUTE) != RESET){
   1187              tickstart = HAL_GetTick();
   1188           
   1189             /* Wait till RTC WUTWF flag is reset and if Time out is reached exit */
   1190             while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == SET)
   1191             {
   1192              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1193                {
   1194                 /* Enable the write protection for RTC registers */
   1195                 __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1196          
   1197                 hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1198          
   1199                 /* Process Unlocked */ 
   1200                 __HAL_UNLOCK(hrtc);
   1201          
   1202                 return HAL_TIMEOUT;
   1203                }
   1204              }
   1205            }
   1206            /* Disable the Wake-Up timer */
   1207            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   1208          
   1209            /* Clear flag Wake-Up */
   1210            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   1211          
   1212            tickstart = HAL_GetTick();
   1213          
   1214            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1215            while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
   1216            {
   1217              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1218              {
   1219                /* Enable the write protection for RTC registers */
   1220                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1221          
   1222                hrtc->State = HAL_RTC_STATE_TIMEOUT; 
   1223          
   1224                /* Process Unlocked */ 
   1225                __HAL_UNLOCK(hrtc);
   1226          
   1227                return HAL_TIMEOUT;
   1228              }
   1229            }
   1230          
   1231            /* Configure the Wakeup Timer counter */
   1232            hrtc->Instance->WUTR = (uint32_t)WakeUpCounter;
   1233          
   1234            /* Clear the Wakeup Timer clock source bits in CR register */
   1235            hrtc->Instance->CR &= (uint32_t)~RTC_CR_WUCKSEL;
   1236          
   1237            /* Configure the clock source */
   1238            hrtc->Instance->CR |= (uint32_t)WakeUpClock;
   1239          
   1240            /* RTC WakeUpTimer Interrupt Configuration: EXTI configuration */
   1241            __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_IT();
   1242          
   1243            __HAL_RTC_WAKEUPTIMER_EXTI_ENABLE_RISING_EDGE();
   1244          
   1245            /* Configure the Interrupt in the RTC_CR register */
   1246            __HAL_RTC_WAKEUPTIMER_ENABLE_IT(hrtc,RTC_IT_WUT);
   1247            
   1248            /* Enable the Wakeup Timer */
   1249            __HAL_RTC_WAKEUPTIMER_ENABLE(hrtc);
   1250          
   1251            /* Enable the write protection for RTC registers */
   1252            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1253          
   1254            hrtc->State = HAL_RTC_STATE_READY; 
   1255          
   1256            /* Process Unlocked */
   1257            __HAL_UNLOCK(hrtc);
   1258          
   1259            return HAL_OK;
   1260          }
   1261          
   1262          /**
   1263            * @brief  Deactivate wake up timer counter.
   1264            * @param  hrtc: RTC handle 
   1265            * @retval HAL status
   1266            */
   1267          uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
   1268          {
   1269            uint32_t tickstart = 0U;
   1270          
   1271            /* Process Locked */ 
   1272            __HAL_LOCK(hrtc);
   1273          
   1274            hrtc->State = HAL_RTC_STATE_BUSY;
   1275          
   1276            /* Disable the write protection for RTC registers */
   1277            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1278          
   1279            /* Disable the Wakeup Timer */
   1280            __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
   1281          
   1282            /* In case of interrupt mode is used, the interrupt source must disabled */
   1283            __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
   1284          
   1285            tickstart = HAL_GetTick();
   1286            /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
   1287            while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
   1288            {
   1289              if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1290              {
   1291                /* Enable the write protection for RTC registers */
   1292                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1293          
   1294                hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1295          
   1296                /* Process Unlocked */
   1297                __HAL_UNLOCK(hrtc);
   1298          
   1299                return HAL_TIMEOUT;
   1300              }
   1301            }
   1302          
   1303            /* Enable the write protection for RTC registers */
   1304            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1305          
   1306            hrtc->State = HAL_RTC_STATE_READY;
   1307          
   1308            /* Process Unlocked */
   1309            __HAL_UNLOCK(hrtc);
   1310          
   1311            return HAL_OK;
   1312          }
   1313          
   1314          /**
   1315            * @brief  Get wake up timer counter.
   1316            * @param  hrtc: RTC handle 
   1317            * @retval Counter value
   1318            */
   1319          uint32_t HAL_RTCEx_GetWakeUpTimer(RTC_HandleTypeDef *hrtc)
   1320          {
   1321            /* Get the counter value */
   1322            return ((uint32_t)(hrtc->Instance->WUTR & RTC_WUTR_WUT));
   1323          }
   1324          
   1325          /**
   1326            * @brief  Handle Wake Up Timer interrupt request.
   1327            * @param  hrtc: RTC handle
   1328            * @retval None
   1329            */
   1330          void HAL_RTCEx_WakeUpTimerIRQHandler(RTC_HandleTypeDef *hrtc)
   1331          {  
   1332              /* Get the pending status of the WAKEUPTIMER Interrupt */
   1333              if(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) != RESET)
   1334              {
   1335                /* WAKEUPTIMER callback */ 
   1336                HAL_RTCEx_WakeUpTimerEventCallback(hrtc);
   1337                
   1338                /* Clear the WAKEUPTIMER interrupt pending bit */
   1339                __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   1340              }
   1341          
   1342          
   1343            /* Clear the EXTI's line Flag for RTC WakeUpTimer */
   1344            __HAL_RTC_WAKEUPTIMER_EXTI_CLEAR_FLAG();
   1345            
   1346            /* Change RTC state */
   1347            hrtc->State = HAL_RTC_STATE_READY;
   1348          }
   1349          
   1350          /**
   1351            * @brief  Wake Up Timer callback.
   1352            * @param  hrtc: RTC handle
   1353            * @retval None
   1354            */
   1355          __weak void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
   1356          {
   1357            /* Prevent unused argument(s) compilation warning */
   1358            UNUSED(hrtc);
   1359          
   1360            /* NOTE : This function should not be modified, when the callback is needed,
   1361                      the HAL_RTCEx_WakeUpTimerEventCallback could be implemented in the user file
   1362             */
   1363          }
   1364          
   1365          
   1366          /**
   1367            * @brief  Handle Wake Up Timer Polling.
   1368            * @param  hrtc: RTC handle
   1369            * @param  Timeout: Timeout duration
   1370            * @retval HAL status
   1371            */
   1372          HAL_StatusTypeDef HAL_RTCEx_PollForWakeUpTimerEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1373          {
   1374            uint32_t tickstart = HAL_GetTick();
   1375          
   1376            while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTF) == RESET)
   1377            {
   1378              if(Timeout != HAL_MAX_DELAY)
   1379              {
   1380                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   1381                {
   1382                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1383                
   1384                  return HAL_TIMEOUT;
   1385                }
   1386              }
   1387            }
   1388          
   1389            /* Clear the WAKEUPTIMER Flag */
   1390            __HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(hrtc, RTC_FLAG_WUTF);
   1391            
   1392            /* Change RTC state */
   1393            hrtc->State = HAL_RTC_STATE_READY;
   1394          
   1395            return HAL_OK;
   1396          }
   1397          
   1398          /**
   1399            * @}
   1400            */
   1401          
   1402          
   1403          /** @addtogroup RTCEx_Exported_Functions_Group3
   1404            * @brief    Extended Peripheral Control functions
   1405            *
   1406          @verbatim   
   1407           ===============================================================================
   1408                        ##### Extended Peripheral Control functions #####
   1409           ===============================================================================  
   1410              [..]
   1411              This subsection provides functions allowing to
   1412                (+) Write a data in a specified RTC Backup data register
   1413                (+) Read a data in a specified RTC Backup data register
   1414                (+) Set the Coarse calibration parameters.
   1415                (+) Deactivate the Coarse calibration parameters
   1416                (+) Set the Smooth calibration parameters.
   1417                (+) Configure the Synchronization Shift Control Settings.
   1418                (+) Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1419                (+) Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1420                (+) Enable the RTC reference clock detection.
   1421                (+) Disable the RTC reference clock detection.
   1422                (+) Enable the Bypass Shadow feature.
   1423                (+) Disable the Bypass Shadow feature.
   1424          
   1425          @endverbatim
   1426            * @{
   1427            */
   1428          
   1429          /**
   1430            * @brief  Write a data in a specified RTC Backup data register.
   1431            * @param  hrtc: RTC handle 
   1432            * @param  BackupRegister: RTC Backup data Register number.
   1433            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1434            *                                 specify the register.
   1435            * @param  Data: Data to be written in the specified RTC Backup data register.
   1436            * @retval None
   1437            */
   1438          void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
   1439          {
   1440            uint32_t tmp = 0U;
   1441          
   1442            /* Check the parameters */
   1443            assert_param(IS_RTC_BKP(BackupRegister));
   1444          
   1445            tmp = (uint32_t)&(hrtc->Instance->BKP0R);
   1446            tmp += (BackupRegister * 4U);
   1447          
   1448            /* Write the specified register */
   1449            *(__IO uint32_t *)tmp = (uint32_t)Data;
   1450          }
   1451          
   1452          /**
   1453            * @brief  Reads data from the specified RTC Backup data Register.
   1454            * @param  hrtc: RTC handle 
   1455            * @param  BackupRegister: RTC Backup data Register number.
   1456            *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
   1457            *                                 specify the register.
   1458            * @retval Read value
   1459            */
   1460          uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
   1461          {
   1462            uint32_t tmp = 0U;
   1463          
   1464            /* Check the parameters */
   1465            assert_param(IS_RTC_BKP(BackupRegister));
   1466          
   1467            tmp = (uint32_t)&(hrtc->Instance->BKP0R);
   1468            tmp += (BackupRegister * 4U);
   1469            
   1470            /* Read the specified register */
   1471            return (*(__IO uint32_t *)tmp);
   1472          }
   1473          
   1474          /**
   1475            * @brief  Set the Smooth calibration parameters.
   1476            * @param  hrtc: RTC handle  
   1477            * @param  SmoothCalibPeriod: Select the Smooth Calibration Period.
   1478            *          This parameter can be can be one of the following values :
   1479            *             @arg RTC_SMOOTHCALIB_PERIOD_32SEC: The smooth calibration period is 32s.
   1480            *             @arg RTC_SMOOTHCALIB_PERIOD_16SEC: The smooth calibration period is 16s.
   1481            *             @arg RTC_SMOOTHCALIB_PERIOD_8SEC: The smooth calibration period is 8s.
   1482            * @param  SmoothCalibPlusPulses: Select to Set or reset the CALP bit.
   1483            *          This parameter can be one of the following values:
   1484            *             @arg RTC_SMOOTHCALIB_PLUSPULSES_SET: Add one RTCCLK pulse every 2*11 pulses.
   1485            *             @arg RTC_SMOOTHCALIB_PLUSPULSES_RESET: No RTCCLK pulses are added.
   1486            * @param  SmoothCalibMinusPulsesValue: Select the value of CALM[8:0] bits.
   1487            *          This parameter can be one any value from 0 to 0x000001FF.
   1488            * @note   To deactivate the smooth calibration, the field SmoothCalibPlusPulses 
   1489            *         must be equal to SMOOTHCALIB_PLUSPULSES_RESET and the field
   1490            *         SmoothCalibMinusPulsesValue mut be equal to 0.
   1491            * @retval HAL status
   1492            */
   1493          HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmoothCalibMinusPulsesValue)
   1494          {
   1495            uint32_t tickstart = 0U;
   1496          
   1497            /* Check the parameters */
   1498            assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(SmoothCalibPeriod));
   1499            assert_param(IS_RTC_SMOOTH_CALIB_PLUS(SmoothCalibPlusPulses));
   1500            assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmoothCalibMinusPulsesValue));
   1501          
   1502            /* Process Locked */ 
   1503            __HAL_LOCK(hrtc);
   1504          
   1505            hrtc->State = HAL_RTC_STATE_BUSY;
   1506          
   1507            /* Disable the write protection for RTC registers */
   1508            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1509          
   1510            /* check if a calibration is pending*/
   1511            if((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
   1512            {
   1513              tickstart = HAL_GetTick();
   1514          
   1515              /* check if a calibration is pending*/
   1516              while((hrtc->Instance->ISR & RTC_ISR_RECALPF) != RESET)
   1517              {
   1518                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1519                {
   1520                  /* Enable the write protection for RTC registers */
   1521                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1522          
   1523                  /* Change RTC state */
   1524                  hrtc->State = HAL_RTC_STATE_TIMEOUT; 
   1525                  
   1526                  /* Process Unlocked */
   1527                  __HAL_UNLOCK(hrtc);
   1528          
   1529                  return HAL_TIMEOUT;
   1530                }
   1531              }
   1532            }
   1533          
   1534            /* Configure the Smooth calibration settings */
   1535            hrtc->Instance->CALR = (uint32_t)((uint32_t)SmoothCalibPeriod | (uint32_t)SmoothCalibPlusPulses | (uint32_t)SmoothCalibMinusPulsesValue);
   1536          
   1537            /* Enable the write protection for RTC registers */
   1538            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1539          
   1540            /* Change RTC state */
   1541            hrtc->State = HAL_RTC_STATE_READY; 
   1542          
   1543            /* Process Unlocked */
   1544            __HAL_UNLOCK(hrtc);
   1545          
   1546            return HAL_OK;
   1547          }
   1548          
   1549          /**
   1550            * @brief  Configure the Synchronization Shift Control Settings.
   1551            * @note   When REFCKON is set, firmware must not write to Shift control register. 
   1552            * @param  hrtc: RTC handle    
   1553            * @param  ShiftAdd1S: Select to add or not 1 second to the time calendar.
   1554            *          This parameter can be one of the following values :
   1555            *             @arg RTC_SHIFTADD1S_SET: Add one second to the clock calendar. 
   1556            *             @arg RTC_SHIFTADD1S_RESET: No effect.
   1557            * @param  ShiftSubFS: Select the number of Second Fractions to substitute.
   1558            *          This parameter can be one any value from 0 to 0x7FFF.
   1559            * @retval HAL status
   1560            */
   1561          HAL_StatusTypeDef HAL_RTCEx_SetSynchroShift(RTC_HandleTypeDef* hrtc, uint32_t ShiftAdd1S, uint32_t ShiftSubFS)
   1562          {
   1563            uint32_t tickstart = 0U;
   1564          
   1565            /* Check the parameters */
   1566            assert_param(IS_RTC_SHIFT_ADD1S(ShiftAdd1S));
   1567            assert_param(IS_RTC_SHIFT_SUBFS(ShiftSubFS));
   1568          
   1569            /* Process Locked */ 
   1570            __HAL_LOCK(hrtc);
   1571          
   1572            hrtc->State = HAL_RTC_STATE_BUSY;
   1573          
   1574            /* Disable the write protection for RTC registers */
   1575            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1576          
   1577              tickstart = HAL_GetTick();
   1578          
   1579              /* Wait until the shift is completed*/
   1580              while((hrtc->Instance->ISR & RTC_ISR_SHPF) != RESET)
   1581              {
   1582                if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
   1583                {
   1584                  /* Enable the write protection for RTC registers */
   1585                  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1586          
   1587                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1588          
   1589                  /* Process Unlocked */ 
   1590                  __HAL_UNLOCK(hrtc);
   1591          
   1592                  return HAL_TIMEOUT;
   1593                }
   1594              }
   1595          
   1596              /* Check if the reference clock detection is disabled */
   1597              if((hrtc->Instance->CR & RTC_CR_REFCKON) == RESET)
   1598              {
   1599                /* Configure the Shift settings */
   1600                hrtc->Instance->SHIFTR = (uint32_t)(uint32_t)(ShiftSubFS) | (uint32_t)(ShiftAdd1S);
   1601          
   1602                /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
   1603                if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
   1604                {
   1605                  if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
   1606                  {
   1607                    /* Enable the write protection for RTC registers */
   1608                    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1609          
   1610                    hrtc->State = HAL_RTC_STATE_ERROR;
   1611          
   1612                    /* Process Unlocked */ 
   1613                    __HAL_UNLOCK(hrtc);
   1614          
   1615                    return HAL_ERROR;
   1616                  }
   1617                }
   1618              }
   1619              else
   1620              {
   1621                /* Enable the write protection for RTC registers */
   1622                __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1623                
   1624                /* Change RTC state */
   1625                hrtc->State = HAL_RTC_STATE_ERROR;
   1626                
   1627                /* Process Unlocked */ 
   1628                __HAL_UNLOCK(hrtc);
   1629          
   1630                return HAL_ERROR;
   1631              }
   1632          
   1633            /* Enable the write protection for RTC registers */
   1634            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1635          
   1636            /* Change RTC state */
   1637            hrtc->State = HAL_RTC_STATE_READY;
   1638          
   1639            /* Process Unlocked */
   1640            __HAL_UNLOCK(hrtc);
   1641          
   1642            return HAL_OK;
   1643          }
   1644          
   1645          /**
   1646            * @brief  Configure the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1647            * @param  hrtc: RTC handle
   1648            * @param  CalibOutput : Select the Calibration output Selection .
   1649            *          This parameter can be one of the following values:
   1650            *             @arg RTC_CALIBOUTPUT_512HZ: A signal has a regular waveform at 512Hz.
   1651            *             @arg RTC_CALIBOUTPUT_1HZ: A signal has a regular waveform at 1Hz.
   1652            * @retval HAL status
   1653            */
   1654          HAL_StatusTypeDef HAL_RTCEx_SetCalibrationOutPut(RTC_HandleTypeDef* hrtc, uint32_t CalibOutput)
   1655          {
   1656            /* Check the parameters */
   1657            assert_param(IS_RTC_CALIB_OUTPUT(CalibOutput));
   1658          
   1659            /* Process Locked */
   1660            __HAL_LOCK(hrtc);
   1661          
   1662            hrtc->State = HAL_RTC_STATE_BUSY;
   1663          
   1664            /* Disable the write protection for RTC registers */
   1665            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1666          
   1667            /* Clear flags before config */
   1668            hrtc->Instance->CR &= (uint32_t)~RTC_CR_COSEL;
   1669          
   1670            /* Configure the RTC_CR register */
   1671            hrtc->Instance->CR |= (uint32_t)CalibOutput;
   1672          
   1673            __HAL_RTC_CALIBRATION_OUTPUT_ENABLE(hrtc);
   1674          
   1675            /* Enable the write protection for RTC registers */
   1676            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1677          
   1678            /* Change RTC state */
   1679            hrtc->State = HAL_RTC_STATE_READY;
   1680          
   1681            /* Process Unlocked */
   1682            __HAL_UNLOCK(hrtc);
   1683          
   1684            return HAL_OK;
   1685          }
   1686          
   1687          /**
   1688            * @brief  Deactivate the Calibration Pinout (RTC_CALIB) Selection (1Hz or 512Hz).
   1689            * @param  hrtc: RTC handle
   1690            * @retval HAL status
   1691            */
   1692          HAL_StatusTypeDef HAL_RTCEx_DeactivateCalibrationOutPut(RTC_HandleTypeDef* hrtc)
   1693          {
   1694            /* Process Locked */ 
   1695            __HAL_LOCK(hrtc);
   1696          
   1697            hrtc->State = HAL_RTC_STATE_BUSY;
   1698          
   1699            /* Disable the write protection for RTC registers */
   1700            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1701          
   1702            __HAL_RTC_CALIBRATION_OUTPUT_DISABLE(hrtc);
   1703          
   1704            /* Enable the write protection for RTC registers */
   1705            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1706          
   1707            /* Change RTC state */
   1708            hrtc->State = HAL_RTC_STATE_READY;
   1709          
   1710            /* Process Unlocked */
   1711            __HAL_UNLOCK(hrtc);
   1712          
   1713            return HAL_OK;
   1714          }
   1715          
   1716          /**
   1717            * @brief  Enable the RTC reference clock detection.
   1718            * @param  hrtc: RTC handle
   1719            * @retval HAL status
   1720            */
   1721          HAL_StatusTypeDef HAL_RTCEx_SetRefClock(RTC_HandleTypeDef* hrtc)
   1722          {
   1723            /* Process Locked */
   1724            __HAL_LOCK(hrtc);
   1725          
   1726            hrtc->State = HAL_RTC_STATE_BUSY;
   1727          
   1728            /* Disable the write protection for RTC registers */
   1729            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1730          
   1731            /* Set Initialization mode */
   1732            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   1733            {
   1734              /* Enable the write protection for RTC registers */
   1735              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1736          
   1737              /* Set RTC state*/
   1738              hrtc->State = HAL_RTC_STATE_ERROR;
   1739          
   1740              /* Process Unlocked */
   1741              __HAL_UNLOCK(hrtc);
   1742          
   1743              return HAL_ERROR;
   1744            }
   1745            else
   1746            {
   1747              __HAL_RTC_CLOCKREF_DETECTION_ENABLE(hrtc);
   1748          
   1749              /* Exit Initialization mode */
   1750              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
   1751            }
   1752          
   1753            /* Enable the write protection for RTC registers */
   1754            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1755          
   1756             /* Change RTC state */
   1757            hrtc->State = HAL_RTC_STATE_READY;
   1758          
   1759            /* Process Unlocked */
   1760            __HAL_UNLOCK(hrtc);
   1761          
   1762            return HAL_OK;
   1763          }
   1764          
   1765          /**
   1766            * @brief  Disable the RTC reference clock detection.
   1767            * @param  hrtc: RTC handle
   1768            * @retval HAL status
   1769            */
   1770          HAL_StatusTypeDef HAL_RTCEx_DeactivateRefClock(RTC_HandleTypeDef* hrtc)
   1771          {
   1772            /* Process Locked */
   1773            __HAL_LOCK(hrtc);
   1774          
   1775            hrtc->State = HAL_RTC_STATE_BUSY;
   1776          
   1777            /* Disable the write protection for RTC registers */
   1778            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1779            
   1780            /* Set Initialization mode */
   1781            if(RTC_EnterInitMode(hrtc) != HAL_OK)
   1782            {
   1783              /* Enable the write protection for RTC registers */
   1784              __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1785          
   1786              /* Set RTC state*/
   1787              hrtc->State = HAL_RTC_STATE_ERROR;
   1788          
   1789              /* Process Unlocked */
   1790              __HAL_UNLOCK(hrtc);
   1791          
   1792              return HAL_ERROR;
   1793            }
   1794            else
   1795            {
   1796              __HAL_RTC_CLOCKREF_DETECTION_DISABLE(hrtc);
   1797          
   1798              /* Exit Initialization mode */
   1799              hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
   1800            }
   1801          
   1802            /* Enable the write protection for RTC registers */
   1803            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1804          
   1805            /* Change RTC state */
   1806            hrtc->State = HAL_RTC_STATE_READY;
   1807          
   1808            /* Process Unlocked */
   1809            __HAL_UNLOCK(hrtc);
   1810          
   1811            return HAL_OK;
   1812          }
   1813          
   1814          /**
   1815            * @brief  Enable the Bypass Shadow feature.
   1816            * @param  hrtc: RTC handle
   1817            * @note   When the Bypass Shadow is enabled the calendar value are taken
   1818            *         directly from the Calendar counter.
   1819            * @retval HAL status
   1820            */
   1821          HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef* hrtc)
   1822          {
   1823            /* Process Locked */
   1824            __HAL_LOCK(hrtc);
   1825          
   1826            hrtc->State = HAL_RTC_STATE_BUSY;
   1827          
   1828            /* Disable the write protection for RTC registers */
   1829            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1830          
   1831            /* Set the BYPSHAD bit */
   1832            hrtc->Instance->CR |= (uint8_t)RTC_CR_BYPSHAD;
   1833          
   1834            /* Enable the write protection for RTC registers */
   1835            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1836          
   1837            /* Change RTC state */
   1838            hrtc->State = HAL_RTC_STATE_READY;
   1839          
   1840            /* Process Unlocked */
   1841            __HAL_UNLOCK(hrtc);
   1842          
   1843            return HAL_OK;
   1844          }
   1845          
   1846          /**
   1847            * @brief  Disable the Bypass Shadow feature.
   1848            * @param  hrtc: RTC handle
   1849            * @note   When the Bypass Shadow is enabled the calendar value are taken
   1850            *         directly from the Calendar counter.
   1851            * @retval HAL status
   1852            */
   1853          HAL_StatusTypeDef HAL_RTCEx_DisableBypassShadow(RTC_HandleTypeDef* hrtc)
   1854          {
   1855            /* Process Locked */
   1856            __HAL_LOCK(hrtc);
   1857          
   1858            hrtc->State = HAL_RTC_STATE_BUSY;
   1859          
   1860            /* Disable the write protection for RTC registers */
   1861            __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
   1862          
   1863            /* Reset the BYPSHAD bit */
   1864            hrtc->Instance->CR &= ((uint8_t)~RTC_CR_BYPSHAD);
   1865          
   1866            /* Enable the write protection for RTC registers */
   1867            __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
   1868          
   1869            /* Change RTC state */
   1870            hrtc->State = HAL_RTC_STATE_READY;
   1871          
   1872            /* Process Unlocked */
   1873            __HAL_UNLOCK(hrtc);
   1874          
   1875            return HAL_OK;
   1876          }
   1877          
   1878          /**
   1879            * @}
   1880            */
   1881          
   1882          /** @addtogroup RTCEx_Exported_Functions_Group4
   1883            * @brief    Extended features functions
   1884            *
   1885          @verbatim   
   1886           ===============================================================================
   1887                           ##### Extended features functions #####
   1888           ===============================================================================  
   1889              [..]  This section provides functions allowing to:
   1890                (+) RTC Alram B callback
   1891                (+) RTC Poll for Alarm B request
   1892                         
   1893          @endverbatim
   1894            * @{
   1895            */
   1896          
   1897          /**
   1898            * @brief  Alarm B callback.
   1899            * @param  hrtc: RTC handle
   1900            * @retval None
   1901            */
   1902          __weak void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
   1903          {
   1904            /* Prevent unused argument(s) compilation warning */
   1905            UNUSED(hrtc);
   1906          
   1907            /* NOTE : This function should not be modified, when the callback is needed,
   1908                      the HAL_RTCEx_AlarmBEventCallback could be implemented in the user file
   1909             */
   1910          }
   1911          
   1912          /**
   1913            * @brief  Handle Alarm B Polling request.
   1914            * @param  hrtc: RTC handle
   1915            * @param  Timeout: Timeout duration
   1916            * @retval HAL status
   1917            */
   1918          HAL_StatusTypeDef HAL_RTCEx_PollForAlarmBEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
   1919          { 
   1920            uint32_t tickstart = HAL_GetTick();
   1921            
   1922            while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) == RESET)
   1923            {
   1924              if(Timeout != HAL_MAX_DELAY)
   1925              {
   1926                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   1927                {
   1928                  hrtc->State = HAL_RTC_STATE_TIMEOUT;
   1929                  return HAL_TIMEOUT;
   1930                }
   1931              }
   1932            }
   1933          
   1934            /* Clear the Alarm Flag */
   1935            __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
   1936          
   1937            /* Change RTC state */
   1938            hrtc->State = HAL_RTC_STATE_READY;
   1939          
   1940            return HAL_OK;
   1941          }
   1942          
   1943          /**
   1944            * @}
   1945            */
   1946          
   1947          /**
   1948            * @}
   1949            */
   1950            
   1951          #endif /* HAL_RTC_MODULE_ENABLED */
   1952          /**
   1953            * @}
   1954            */
   1955          
   1956          
   1957          /**
   1958            * @}
   1959            */
   1960          
   1961          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
   1962          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RTCEx_AlarmBEventCallback
       0   HAL_RTCEx_BKUPRead
       0   HAL_RTCEx_BKUPWrite
       8   HAL_RTCEx_DeactivateCalibrationOutPut
      24   HAL_RTCEx_DeactivateRefClock
        24   -> RTC_EnterInitMode
      12   HAL_RTCEx_DeactivateTamper
       8   HAL_RTCEx_DeactivateTimeStamp
      16   HAL_RTCEx_DeactivateWakeUpTimer
        16   -> HAL_GetTick
       8   HAL_RTCEx_DisableBypassShadow
       8   HAL_RTCEx_EnableBypassShadow
      24   HAL_RTCEx_GetTimeStamp
        24   -> RTC_Bcd2ToByte
       0   HAL_RTCEx_GetWakeUpTimer
      16   HAL_RTCEx_PollForAlarmBEvent
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTamper1Event
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTamper2Event
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTamper3Event
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForTimeStampEvent
        16   -> HAL_GetTick
      16   HAL_RTCEx_PollForWakeUpTimerEvent
        16   -> HAL_GetTick
      12   HAL_RTCEx_SetCalibrationOutPut
      24   HAL_RTCEx_SetRefClock
        24   -> RTC_EnterInitMode
      32   HAL_RTCEx_SetSmoothCalib
        32   -> HAL_GetTick
      32   HAL_RTCEx_SetSynchroShift
        32   -> HAL_GetTick
        32   -> HAL_RTC_WaitForSynchro
      20   HAL_RTCEx_SetTamper
      20   HAL_RTCEx_SetTamper_IT
      12   HAL_RTCEx_SetTimeStamp
      12   HAL_RTCEx_SetTimeStamp_IT
      32   HAL_RTCEx_SetWakeUpTimer
        32   -> HAL_GetTick
      32   HAL_RTCEx_SetWakeUpTimer_IT
        32   -> HAL_GetTick
       0   HAL_RTCEx_Tamper1EventCallback
       0   HAL_RTCEx_Tamper2EventCallback
       0   HAL_RTCEx_Tamper3EventCallback
      16   HAL_RTCEx_TamperTimeStampIRQHandler
        16   -> HAL_RTCEx_Tamper1EventCallback
        16   -> HAL_RTCEx_Tamper2EventCallback
        16   -> HAL_RTCEx_Tamper3EventCallback
        16   -> HAL_RTCEx_TimeStampEventCallback
       0   HAL_RTCEx_TimeStampEventCallback
       0   HAL_RTCEx_WakeUpTimerEventCallback
       8   HAL_RTCEx_WakeUpTimerIRQHandler
         8   -> HAL_RTCEx_WakeUpTimerEventCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable19
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable8
      14  ??Subroutine9_0
      10  ?Subroutine0
      24  ?Subroutine1
      26  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
      14  ?Subroutine5
       8  ?Subroutine6
      30  ?Subroutine7
      18  ?Subroutine8
       2  HAL_RTCEx_AlarmBEventCallback
      12  HAL_RTCEx_BKUPRead
      12  HAL_RTCEx_BKUPWrite
      44  HAL_RTCEx_DeactivateCalibrationOutPut
      68  HAL_RTCEx_DeactivateRefClock
      78  HAL_RTCEx_DeactivateTamper
      58  HAL_RTCEx_DeactivateTimeStamp
     124  HAL_RTCEx_DeactivateWakeUpTimer
      46  HAL_RTCEx_DisableBypassShadow
      48  HAL_RTCEx_EnableBypassShadow
     136  HAL_RTCEx_GetTimeStamp
       8  HAL_RTCEx_GetWakeUpTimer
      54  HAL_RTCEx_PollForAlarmBEvent
      54  HAL_RTCEx_PollForTamper1Event
      52  HAL_RTCEx_PollForTamper2Event
      54  HAL_RTCEx_PollForTamper3Event
      74  HAL_RTCEx_PollForTimeStampEvent
      54  HAL_RTCEx_PollForWakeUpTimerEvent
      62  HAL_RTCEx_SetCalibrationOutPut
      68  HAL_RTCEx_SetRefClock
     128  HAL_RTCEx_SetSmoothCalib
     158  HAL_RTCEx_SetSynchroShift
     180  HAL_RTCEx_SetTamper
     198  HAL_RTCEx_SetTamper_IT
      60  HAL_RTCEx_SetTimeStamp
      90  HAL_RTCEx_SetTimeStamp_IT
     144  HAL_RTCEx_SetWakeUpTimer
     188  HAL_RTCEx_SetWakeUpTimer_IT
       2  HAL_RTCEx_Tamper1EventCallback
       2  HAL_RTCEx_Tamper2EventCallback
       2  HAL_RTCEx_Tamper3EventCallback
     158  HAL_RTCEx_TamperTimeStampIRQHandler
       2  HAL_RTCEx_TimeStampEventCallback
       2  HAL_RTCEx_WakeUpTimerEventCallback
      48  HAL_RTCEx_WakeUpTimerIRQHandler

 
 2 754 bytes in section .text
 
 2 742 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: none
